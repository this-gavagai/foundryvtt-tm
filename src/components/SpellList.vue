<script setup lang="ts">
// TODO (feature): deal with flexible prepared casters
// TODO (data): makePropertiesHTML needs re-implementation post-types implementation
// TODO (data): staves generated by pf2e-dailies aren't showing up

import type { SpellcastingEntry, Spell, Item } from '@/composables/character'
import { inject, computed, ref } from 'vue'
import { capitalize, removeUUIDs } from '@/utils/utilities'
import { useKeys } from '@/composables/injectKeys'

import Button from '@/components/ButtonWidget.vue'
import CounterWidget from '@/components/CounterWidget.vue'
import Modal from '@/components/ModalBox.vue'
import InfoModal from '@/components/InfoModal.vue'
import ActionIcons from '@/components/ActionIcons.vue'

interface Spellbook {
  [key: string]: { [key: string]: [Item?] }
}
interface SpellInfo {
  type?: 'focus' | 'charge' | 'spontaneous' | 'prepared' | 'wand'
  entry?: Spell
  entryId?: string
  castingRank?: number
  castingSlot?: number
  isConsumable?: boolean
}

const character = inject(useKeys().characterKey)!
const { spellcastingEntries, spells, spellConsumables, spellDC } = character
const { max: focusMax, current: focusCurrent } = character.focusPoints

const infoModal = ref()
const spellSelectionModal = ref()
const castButton = ref()
const consumeButton = ref()
const removeButton = ref()

// TODO: this viewedSpell thing is annoying. It exists only to serve the infomodal Possible to just pass the full object to the infomodal?
const viewedSpell = computed(() =>
  [...(spells.value ?? []), ...(spellConsumables.value ?? [])]?.find(
    (i: Spell) => i._id === infoModal?.value?.itemId
  )
)

const spellbook = computed((): Spellbook => {
  const sb: Spellbook = {} // {location - rank - spell}
  // set spellcastingEntry locations with empty ranks template
  spellcastingEntries.value?.forEach((se: SpellcastingEntry) => {
    const location = se._id ?? ''
    // prettier-ignore
    sb[location] = { '0': [], '1': [], '2': [], '3': [], '4': [], '5': [], '6': [], '7': [], '8': [], '9': [], '10': [] }
  })
  // assign spells to spellbook ranks
  for (const locationId of Object.keys(sb)) {
    const location = spellcastingEntries.value?.find((i: Item) => i._id === locationId)
    if (location?.system.prepared.value === 'prepared') {
      Object.values(location.system.slots).forEach((slot, slotRank: number) => {
        const preparedSpells = slot.prepared.map((slotSpell) =>
          spells.value?.find((i: Item) => i._id === slotSpell.id)
        )
        const spellSlots = Object.assign(new Array(slot.max), preparedSpells.slice(0, slot.max))
        sb[locationId][slotRank] = spellSlots as [Item]
      })
    } else {
      const spellsForLocation = spells.value?.filter(
        (i: Item) => i.type === 'spell' && i.system.location.value === locationId
      )
      spellsForLocation?.forEach((s: Item) => {
        const rank = s.system.traits.value?.includes('cantrip') ? '0' : String(s.system.level.value)
        sb[locationId][rank].push(s)
        // add signature spells by iterating through spellslots property
        if (s.system.location.signature) {
          Object.values(location?.system?.slots ?? {}).forEach((slot, slotRank) => {
            if (slot.max && slotRank > (s.system.level.value ?? NaN)) {
              sb[locationId][slotRank].push(s)
            }
          })
        }
      })
      // put signature spells at the end
      const spellRanks = Object.entries(sb[locationId]) as [string, [(Item | undefined)?]][]
      spellRanks.forEach((rank: [string, [(Item | undefined)?]]) => {
        rank[1]
          .sort(
            (a: Item | undefined, b: Item | undefined) =>
              (a?.system.level.value ?? NaN) - (b?.system.level.value ?? NaN)
          )
          .sort(
            (a: Item | undefined, b: Item | undefined) =>
              (a?.system.level.value == Number(rank[0]) ? 0 : 1) -
              (b?.system.level.value == Number(rank[0]) ? 0 : 1)
          )
      })
    }
  }
  return sb
})
</script>
<template>
  <div v-if="spellcastingEntries?.length === 0" class="px-6 py-4 italic">
    This character does not cast spells.
  </div>
  <div v-else class="">
    <ul class="">
      <!-- Spell Sources -->
      <li v-for="location in spellcastingEntries" class="mb-4" :key="location._id">
        <h3 class="flex justify-between bg-gray-300 px-4 py-2 align-bottom">
          <span>
            <span class="text-xl">
              {{ location.name }}
            </span>
            <span v-if="location.system.spelldc.dc || spellDC" class="text-xs">
              (DC {{ location.system.spelldc.dc || spellDC }})
            </span>
          </span>
          <span class="pl-1">
            <CounterWidget
              v-if="location.system?.prepared.value === 'focus'"
              class="relative bottom-[-2px] mr-2 text-sm"
              :value="focusCurrent"
              :max="focusMax"
              title="Focus Pool"
              editable
              @change-count="(newTotal) => (focusCurrent = newTotal)"
            />
            <CounterWidget
              v-if="location.system?.prepared.value === 'charge'"
              class="relative bottom-[-2px] mr-2 text-sm"
              :value="location.staffCharges"
              :title="location.name"
              editable
              @change-count="(newTotal) => location.setCharges(newTotal)"
            />
          </span>
        </h3>
        <!-- Spell Ranks -->
        <ul>
          <li
            v-for="(spells, rank) in spellbook[location._id ?? '']"
            class=""
            :class="{ hidden: !spells.length }"
            :key="'rank' + rank"
          >
            <h4 class="flex justify-between bg-gray-200 px-4 align-bottom text-sm italic">
              <span class="pr-1">
                {{ rank == '0' ? 'Cantrips' : 'Rank ' + rank }}
              </span>
              <CounterWidget
                class="relative bottom-[-1px] mr-2 text-sm"
                v-if="location.system?.prepared.value === 'spontaneous'"
                :value="location.system.slots?.['slot' + rank]?.value"
                :max="location.system.slots?.['slot' + rank]?.max"
                editable
                :title="`${location?.name}: Rank ${rank}`"
                @change-count="(newTotal) => location?.setSlotCount(Number(rank), newTotal)"
              />
            </h4>
            <!-- Spells -->
            <ul class="mb-1 empty:hidden">
              <li
                v-for="(spell, index) in spells"
                class="flex justify-between px-4"
                :key="spell?._id"
              >
                <div class="text-md">
                  <span
                    v-if="spell"
                    @click="
                      infoModal.open(spell?._id, {
                        entry: location,
                        entryId: location._id,
                        castingRank: Number(rank),
                        castingSlot: index
                      } as SpellInfo)
                    "
                    class="cursor-pointer"
                  >
                    <span
                      v-if="
                        spell?.system?.location?.signature &&
                        spell?.system?.level.value !== Number(rank)
                      "
                      >*</span
                    >
                    <span>{{ spell?.name }}</span>
                    <ActionIcons class="text-md ml-1" :actions="spell?.system?.time?.value" />
                  </span>
                  <span
                    v-else
                    @click="
                      spellSelectionModal.open({
                        entry: location,
                        entryId: location._id,
                        castingRank: Number(rank),
                        castingSlot: index
                      } as SpellInfo)
                    "
                    class="cursor-pointer text-gray-500"
                    >(empty)</span
                  >
                </div>
                <CounterWidget
                  class="relative bottom-[-1px] mr-2 text-sm"
                  v-if="location.system?.prepared.value === 'prepared'"
                  :value="
                    location.system.slots['slot' + rank].prepared[index]?.expended === false ? 1 : 0
                  "
                  :max="1"
                  editable
                  :title="`Rank ${rank}: ${spell?.name}`"
                  @change-count="
                    (newTotal) =>
                      location?.setPrepared(
                        Number(rank),
                        index,
                        spell?._id ?? null,
                        newTotal ? false : true
                      )
                  "
                />
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <!-- Wands and Scrolls -->
      <li class="mt-4 [&:not(:has(li))]:hidden">
        <h3 class="flex justify-between bg-gray-300 px-4 py-2 align-bottom">
          <span>
            <span class="text-xl underline"> Wands and Scrolls </span>
            <span v-if="spellDC" class="text-xs"> (DC {{ spellDC }}) </span>
          </span>
        </h3>
        <ul class="pb-4 empty:hidden">
          <li
            v-for="item in spellConsumables?.sort(
              (a, b) =>
                (a.system.spell.system.level.value ?? 0) - (b.system.spell.system.level.value ?? 0)
            )"
            class="flex justify-between px-4"
            :key="item._id"
          >
            <div>
              <span
                v-if="item"
                @click="infoModal.open(item?._id, { isConsumable: true } as SpellInfo)"
                class="cursor-pointer"
              >
                {{ item.name }}
              </span>
            </div>
            <CounterWidget
              class="relative bottom-[-1px] mr-2 text-sm"
              :value="item.system.uses?.value"
              :max="item.system.uses?.max"
              :title="item.name"
              editable
              @change-count="(newTotal) => item?.changeUses?.(newTotal)"
            />
          </li>
        </ul>
      </li>
    </ul>
  </div>
  <Teleport to="#modals">
    <InfoModal
      ref="infoModal"
      :imageUrl="viewedSpell?.img"
      :traits="viewedSpell?.system?.traits?.value"
    >
      <template #title>
        {{ viewedSpell?.name }}
        <ActionIcons
          class="relative -mt-[.5rem] pl-1 text-2xl leading-4"
          :actions="viewedSpell?.system?.time?.value"
        />
      </template>
      <template #description>
        {{
          viewedSpell?.system.traits?.value?.includes('cantrip')
            ? `Cantrip`
            : `Rank ${viewedSpell?.system.level?.value}`
        }}
        <span class="text-sm">{{ capitalize(viewedSpell?.system.traits.rarity) }}</span>
      </template>
      <template #body>
        <div v-if="infoModal.options?.isConsumable">
          <h4 class="text-xl">Spell Details</h4>
          <!-- <div v-html="makePropertiesHtml(viewedSpell?.system.spell)"></div> -->
          <div v-html="removeUUIDs(viewedSpell?.system.spell.system.description?.value)"></div>
          <hr />
          <h4 class="pt-1 text-xl">Wand Details</h4>
        </div>
        <!-- <div v-html="makePropertiesHtml(viewedSpell!)"></div> -->
        <div v-html="removeUUIDs(viewedSpell?.system.description?.value)"></div>
      </template>
      <template #actionButtons>
        <Button
          ref="removeButton"
          label="Remove"
          color="red"
          v-if="infoModal.options?.entry?.system.prepared?.value === 'prepared'"
          @click="
            () => {
              spellcastingEntries
                ?.find((e) => e._id === infoModal?.options?.entryId)
                ?.setPrepared(
                  infoModal?.options?.castingRank,
                  infoModal?.options?.castingSlot,
                  null
                )
              infoModal?.close()
            }
          "
        />
        <Button
          ref="castButton"
          label="Cast"
          color="blue"
          v-if="!infoModal.options?.isConsumable"
          @click="
            (viewedSpell as Spell)
              ?.doSpell?.(infoModal.options.castingRank, infoModal.options.castingSlot)
              ?.then((r) => infoModal.close())
          "
        />
        <Button
          ref="consumeButton"
          label="Use"
          color="green"
          v-if="infoModal.options?.isConsumable"
          type="button"
          @click="
            () => {
              viewedSpell?.consumeItem?.()
              infoModal.close()
            }
          "
        />
      </template>
    </InfoModal>
    <Modal ref="spellSelectionModal" title="Select a spell">
      <ul>
        <li
          class="cursor-pointer"
          v-for="spell in spells?.filter(
            (i) =>
              i.system.location === spellSelectionModal.options?.entryId &&
              (i.system.level.value ?? 0) <= spellSelectionModal.options.castingRank
          )"
          @click="
            () => {
              spellcastingEntries
                ?.find((e) => e._id === spellSelectionModal?.options?.entryId)
                ?.setPrepared(
                  spellSelectionModal?.options?.castingRank,
                  spellSelectionModal?.options?.castingSlot,
                  spell._id ?? null
                )
              spellSelectionModal?.close()
            }
          "
          :key="spell._id"
        >
          {{ spell.name }}
        </li>
      </ul>
    </Modal>
  </Teleport>
</template>
